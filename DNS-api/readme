1 大概流程
dns服务器上将白名单域名列表保存到dnsmasq中，并和ipset中的white_list_dst做关联。dnsmasq会在解析到该域名列表中的域名时，同时将解析到的ip存入ipset的white_list_dst集合中。

iptables服务器和DNS服务器上都将运行一个go程序，其中iptables上的go程序提供api接口，功能为接收一个ipList然后存入本地ipset中相应集合中，该操作为幂等操作。DNS上的go程序的功能为，初始化时建立两个list，并将内容发送给iptables服务器，如果iptables服务器起来了，那么开启监视，如果没起来，则不开启监视，等到iptables起来时，会自动发送一个启动信号过来。当iptables服务器发来信号，则开启监视。监视开启之后，将一直死循环监视ipset list命令中white_list_dst有无变化，通过调用系统shell命令ipset list中的结果和localList对比。

整体流程中，都由DNS服务器上的go程序做调度，iptables中的go只提供接口，只在初始化时主动发起一个请求。

go程序中维护另一个slice（toSendList），保存将要发送给iptables服务器（用以保存到iptables服务器中ipset中的white_list_dst集合中）的ip列表，发送成功（responese确认）后，则删除其中的成功的ip。为了防止iptables服务器中的dst数据重启后丢失，且dns服务器中的toSendList已经发送完毕后删除。为了防止这种情况，iptables服务器启动时将会主动获取一次数据，且是从localList中获取，而不是toSendList。

不管初始化之后还是每次监听到ipset list命令中white_list_dst有变化时。都会将变化的ip保存到toSendList中，然后调用iptables上的goAPI将toSendSilce发送过去保存。调用该API将会返回一个JSON，其中包含一个list，successLis，将successList中的ip从toSendList中去掉。然后继续下一轮监听本地ipset list

DNS中的go程序将会不停的监视本地ipset和内存中保存的有无变化，且每次检查过后，不管有无变化，只要toSendList不为空，都会尝试发送给iptables。

1.	启动DNS的go程序，该程序初始化将提供一个restAPI接口。并在内存中维护两个切片（数组）localList和toSendList。并在初始化时发送第一批数据给iptables，如果能成功连上，则开启监视本地ipset list，并在每次监视到变化时，尝试通过iptables中api接口发送给对方。如果初始化时没连上iptables，则不会开启监听，也不会更新两个list。等待iptables服务器启动后会自动发送一个信号，到时候再启动监视。
2.	启动iptables的api接口。初始化时，会调用DNS的api接口获取当前的localList中的数据，并保存到ipset list中，且会通知对方开启监视。
3.	在DNS服务器的go程序中，每一轮监视，会将变化的ip添加到toSendList中，且，不管有无变化，只要toSendList不为空，都将尝试发送toSendList到iptables服务器中。虽然此时iptables中的ipset经过go程序初始化之后，已经有了大部分IP。但这个操作是幂等操作，所以还是会返回success。DNS服务器收到结果后，就会将success的ip从toSendList中删除。


幂等操作如何实现：
shell命令：ipset add xxx 1.1.1.1 如果该ip已经在xxx中，将会报错，但报错会返回固定字符串，判断是否这个固定字符串。
